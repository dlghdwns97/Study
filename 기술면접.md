1. float와 int의 표현 가능한 수의 범위가 다른 이유는 무엇인가요?
- 둘 다 같은 4바이트 자료형이지만 int형은 있는 그대로의 비트를 보여주고 float형은 부호를 표현하는 비트, 자릿수를 표현하는 비트, 값을 표현하는 비트 3부분으로 나뉘어서 그렇습니다.

2. ref와 out 사용 시 차이는 무엇인가요?
- ref를 사용하면 함수 바깥에 있는 인자를 함수로 넘겨주는 형태로, out을 사용하면 함수 내에서 정의한 값을 바깥으로 넘겨주는 형태로 작동합니다. 그래서 out을 이용한 함수는 함수 바깥에 있는 변수에 값을 할당 할 필요가 없지만 ref를 이용한 함수는 바깥에 있는 변수에 값을 할당해주지 않으면 에러가 발생합니다.

3. 접근제한자란 무엇이며, 각각 어떤 차이가 있는지 비교해서 설명해주세요.
- 접근제한자는 외부로부터 타입 또는 그 멤버들로의 접근을 제한할 때 사용하는 것으로 4종류가 있습니다. public은 모든 외부에서 이 타입에 접근할 수 있습니다. private는 동일 클래스나 구조체 내의 멤버만 접근 가능합니다. protected는 상속 클래스와 선언 클래스에서만 접근 가능합니다. internal은 동일한 같은 프로젝트 같이 어셈블리 내에 있는 다른 타입들만 접근할 수 있습니다. 접근제한자를 사용하지 않으면 기본적으로 internal 이 붙습니다.

- ![img](https://github.com/dlghdwns97/Study/assets/73785455/9898f6f7-3b95-42ae-aa98-75506ab5d854)

4. struct와 class를 비교해서 설명해주세요.
- 구조체는 상속이 불가능하고 값 타입이지만 클래스는 상속이 가능한 참조 타입입니다. 구조체는 스택이라는 메모리 영역에 할당되고 클래스는 힙에 할당하는 값의 주소를 가지고 있습니다. 그래서 사용을 할 때 구조체의 변수는 이미 스택에 할당되어 있어서 바로 불러와 사용이 가능하지만 클래스는 new 키워드를 통해 힙 영역에 할당한 뒤 그 주소값을 참조해야 합니다. C# 의 경우 가비지 컬렉터가 힙에 할당된 메모리 중 사용하지 않는 부분을 정리해주는데 이때 처리해야할 양이 많다면 프로그램이 느려지게 됩니다. 그래서 굳이 힙에 할당하지 않아도 되는 정보의 경우 스택 메모리에서 사용하면 사용 후 바로 종료가 되기 때문에 프로그램 속도 향상에 도움이 될 수 있습니다.

5. 가비지 컬렉터에 대해 설명해주세요.
- 가비지 컬렉터는 필요없는 동적 메모리를 해제하는 C#의 자동 메모리 관리 기능입니다. 가비지 컬렉터는 프로그램을 실행하다가 특정한 타이밍에 현재 할당된 메모리를 조사해서 그것이 현재 접근 가능한 상태인지 불가능한 상태인지 분류한 뒤 접근이 불가능한 메모리를 쓰레기로 간주하여 해제시킵니다. 하지만 모든 메모리를 조사하는건 실시간으로 동작하는 프로그램에서 끊기는 현상을 유발할 수 있기 때문에 요즘은 점진적으로 여러번에 걸쳐서 수행하는 방식을 사용하는 것으로 알고 있습니다.

6. 가비지 컬렉터를 회피하기 위한 전략은 무엇이 있나요?
- 우선 첫번째로 메모리 할당을 최소화시키면 됩니다. 변수를 재사용한다던가 하는 방법으로 할당을 최소화하면 가비지컬렉터의 동작빈도를 줄일 수 있습니다. 두번째로는 가비지컬렉션 메소드를 직접 호출하는 빈도를 줄이고 정말 필요한 경우에만 직접 호출하는 방법이 있습니다. 세번째로는 굳이 참조 타입이 필요하지 않다면 값 타입을 사용하는 방법이 있습니다. 하지만 이 경우에는 코드의 유지보수성이나 최적화에 문제가 될 수 있으므로 실제로 가비지컬렉터가 성능저하를 일으킬 때가 아니면 남발하지 않는 것이 좋다고 생각합니다.

추가 )
IDisposable 인터페이스 사용
IDisposable 인터페이스를 구현한 클래스는 Dispose()메서드를 호출함으로써 자체적으로 리소스를 해제할 수 있다.
이 방법을 통해 가비지 컬렉터가 처리해야 할 작업을 줄일 수 있다.

using (var resource = new DisposableResource()) // IDisposable 인터페이스를 구현한 클래스
{
	resource.Use();
} // using 블록이 끝나면 Dispose() 메서드가 자동으로 호출됨
https://learn.microsoft.com/ko-kr/dotnet/api/system.idisposable?view=net-7.0

Finalizer 사용 최소화
FInalizer는 객체가 가비지 컬렉션에 의해 수거되기 전 호출되는 특수 메서드이다.
Finalizer를 사용하면 가비지 컬렉션의 프로세스가 느려질 수 있으므로, 꼭 필요한 경우에만 사용하는 것이 좋다.

public class ClassWithoutFinalizer
{
	// Finalizer 없음.
}
https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/classes-and-structs/finalizers

7. 가비지 컬렉션이란 무엇인지 설명해주세요.
- 메모리 관리 방법중 하나로 프로그래머가 동적으로 할당한 메모리 영역 중 더 이상 쓰이지 않는 영역을 자동으로 찾아 해제하는 기능입니다. 가비지 컬렉터라는 소프트웨어가 이 기능을 담당하고 있습니다.

8. 박싱과 언박싱에 대하여 설명해주세요.
- 박싱은 값 타입의 개체를 참조 타입으로 변환하는 작업을 말합니다. 언박싱은 반대로 참조 타입으로 있는 개체를 값 타입으로 변환하는 작업을 말합니다.
```csharp
int a = 10;
object b = a; // 박싱
int c = (int)b; // 언박싱
```
(꼬리질문) 박싱, 언박싱을 사용할 때 주의해야 할 점이 있다면 무엇이 있나요?
- 일단 두 작업 모두 스택에서 힙으로 복사, 힙에서 스택으로 복사하는 과정이 추가되기 때문에 리소스를 더 사용하게 됩니다. 그래서 정말 필요한 경우가 아니면 사용하지 않는 것이 좋고 특히 언박싱은 기존과 다른 타입으로 언박싱 하거나 해당 타입보다 작은 범위로 변환을 하면 에러가 호출되기 때문에 is 연산자를 사용해서 미리 같은 타입인지 캐스팅 해보는 작업이 필요합니다.

9. 배열과 List, ArrayList, Dictionary 의 차이점을 설명해주세요.
- 배열은 크기가 고정되어 있는 동일한 타입의 원소 집합입니다. 고정된 크기를 가지고 있어 메모리 효율이 좋고 배열을 구성하는 원소에게 접근이 용이하지만 크기 변경이 불가능하고 데이터를 자주 바꿔야하는 경우엔 알맞지 않습니다. 리스트는 크기가 동적인 동일한 타입의 원소 집합입니다. 원소를 추가하거나 제거하는 경우가 잦다면 배열보다는 리스트를 사용하는 것이 좋습니다. ArrayList는 크기가 동적인 모든 타입의 원소 집합입니다. 리스트와 마찬가지로 원소를 추가하거나 제거하는 경우가 잦을 때 사용하며 모든 타입의 원소를 저장할 수 있습니다. 하지만 제네릭이 없어 타입 안정성은 떨어집니다.(잘못된 데이터를 추가할 수 있음) 딕셔너리는 키와 값의 쌍으로 이루어진 집합입니다. 키를 통해 값을 찾거나 데이터 간의 연관성을 직관적으로 보여줘야 할 때 사용합니다. 키 값은 중복값을 가질 수 없습니다.

(꼬리질문) Dictionary는 어떻게 구현해야 하나요?
- 딕셔너리는 해쉬 테이블 기반으로 구현되어 있습니다. 해쉬는 특정 키를 해쉬 함수를 통해 해쉬 테이블의 주소값으로 변경합니다. 그리고 그 해쉬 함수가 값이 저장될 위치를 가리키고 해당 위치에 값이 저장됩니다.

(꼬리질문) Dictionary 검색이 빠른 이유는 무엇인가요?
- 저장할 때 key 값에 해쉬 함수를 적용해 고유한 index 를 만들어 저장하기 때문입니다. key 를 알면 해쉬 함수를 통해 바로 index 를 알 수 있으므로 데이터를 찾을 때 O(1) 의 평균 시간복잡도로 조회, 삭제가 가능합니다.

### List
C#에서 List가 동적으로 크기를 정할수 있기 때문에 노드 방식으로 생각하고 계신 분들이 계신데 내부적으로는 배열로 구현되어 있습니다.
List<int> myList = new List<int>();
리스트를 만들면 내부적으로는 배열을 미리 생성을 해둡니다.
이때 만들어지는 기본 배열의 0개 짜리입니다.
내부 배열 - [   ]
myList.Add(10);
이후 데이터를 추가하게 되면 배열이 비어있는지 아닌지 체크를 합니다.
비어다면 기본 용량만큼 배열을 새로 만들어줍니다.
(TMI - 기본 용량는 구현체 마다 다르지만 C# 에서는 기본적으로 4개짜리 배열을 생성하게 됩니다.)
내부 배열 - [10][   ][   ][   ]
myList.Add(20);
myList.Add(30);
myList.Add(40);
데이터를 추가하면 배열이 남아 있으면 계속 해서 채워 나갑니다.
내부 배열 - [10][20][30][40]
myList.Add(50);
배열이 꽉찬 상태에서 데이터를 추가하면 배열 사이즈의 2배만큼 새로운 배열을 만듭니다.
이때 기존 배열과 완전히 다른 새로운 배열을 만들어서 데이터를 옮기게 됩니다.
이말은 기존 배열은 아직 유지되어 있는 상태이고 이후 CG의 대상이 됩니다.
내부 배열 - [10][20][30][40][50][   ][   ][   ]       <- 새로 생긴거
기존 배열 - [10][20][30][40]                              <- 이전에 쓰던거 (GC 의 대상)
이렇게 사용해다가면 데이터를 계속 추가를 할때마다 새로운 배열을 만들게 됩니다.
숫자가 가늠이 된다면 List 를 사용하실때도 대략적인 사이즈를 지정해 주신다면 처음 배열을 만들때 내부 배열의 사이즈를 조정할 수 있습니다.
이렇게 된다면 배열을 옮김으로서 생기는 부하를 방지할 수 있습니다.
List<int> myList = new List<int>(10);
내부 배열 - [   ][   ][   ][   ][   ][   ][   ][   ][   ][   ]
결론
리스트는 내부적으로 배열이다.
리스트도 가능하면 배열 크기를 먼저 정해주면 부하를 줄일 수 있다.
리스트의 삽입/삭제시 내부적으로 배열 중간의 데이터를 추가/지우고 다른 데이터를 옮겨야 하기 때문에 성능은 O(n) 이 됩니다. (주의 - 사용이 한번에 된다고 O(1) 이 아닙니다)
리스트 내부 데이터는 메모리에 연속적으로 할당됩니다.(배열이기 때문에)
List 와 Linked List 는 다릅니다.
간략하게 텍스트로 공유드리니 해당 내용 한번 학습해보시면 좋을것같습니다.
아마 List 와 Linked List 의 내용을 혼동하셔서 잘못 작성하신 분들이 계시는것같습니다.
구조를 완벽히 알 필요는 없지만 대략적인 동작원리는 파악하시면 도움이 됩니다.

10. 제네릭이란 무엇인가요?
- 제네릭은 데이터 형식을 지정하지 않고 형식 매개변수로 전달해서 클래스를 정의하는 것을 말합니다. 제네릭을 사용할 경우 데이터 형식별로 클래스를 생성하지 않아 재사용성, 안전성 등을 최대화 할 수 있습니다.
```csharp
using System;

namespace Project
{
    class Program
    {
        static void Main(string[] args)
        {
            GenericQueue<int> intData = new GenericQueue<int>(100);

            intData.Enqueue(100);
            intData.Enqueue(200);
            intData.Enqueue(300);

            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());

            intData.Enqueue(400);
            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());
        }   
    }

    class GenericQueue<T>
    {
        public T[] array;
        private int count = 0;

        public GenericQueue(int length)
        {
            array = new T[length];
        }

        public void Enqueue(T value)
        {
            array[++count] = value;
        } 

        public T Dequeue()
        {
            return count == 0 ? default(T) : array[count--];
        }
    }
}
```

11. 델리게이트(Delegate)의 개념에 대해 설명해주세요.
- 델리게이트는 메서드에 대한 참조를 갖는 형식입니다. 여러 메서드를 등록해 한번의 호출로 등록된 모든 메서드를 호출할 수 있습니다.

12. 'delegate', 'event', 'action', 'func' 간의 차이를 설명해주세요.
- 델리게이트, 액션, func는 일단 모두 델리게이트와 같은 대리자 형태를 가지고 있습니다. 가장 기본적인 형태가 델리게이트이고 action과 func는 C# 내부적으로 정의하고 있는 대리자 입니다. action은 인자만 존재하는 대리자, func은 인자와 결과 값이 모두 존재하는 대리자입니다. 이벤트는 대리자를 오직 변수를 선언한 클래스 내부에서만 쓸 수 있게해주는 키워드 입니다. 이벤트는 클래스 내부에서만 실행할 대리자니 다른 곳에서 사용하지 못하게 하라고 컴파일러에 명시적으로 알려주는 기능을 합니다.

(꼬리질문) 프로젝트에 적용해 본 경험이 있다면 설명해주세요.
- 아직 없..네

13. 람다식(Lambda Expression)이 무엇인지 설명해주세요.
- 람다식은 무명 함수를 표현하는데 사용됩니다. 연산자로는 => 를 사용하며 연산자 왼쪽에 입력 파라미터를, 연산자 오른쪽에 실행할 문장 블럭을 입력합니다. 람다식을 이용하면 델리게이트를 더 간편하게 표현할 수 있습니다.

14. 콜백이란 무엇인가요? 사용해봤는지?
- 콜백은 피호출자가 호출자를 다시 호출하는 것으로 비동기 처리가 많을 때 유용하게 사용됩니다. 콜백에는 객체를 전달하지 않고 메서드를 담아 전달해 사용할 수 있는 델리게이트가 많이 사용됩니다.

15. 정렬 알고리즘이란 무엇이며, 사용 이유에 대해 설명해주세요.
- 어떤 데이터 집합을 정해진 순서대로 나열하는 것을 말합니다. 데이터를 정렬하는 이유는 탐색을 위해서이고 그중에서도 이진 탐색이라는 아주 강력한 알고리즘을 사용하기 위해서 정렬을 사용합니다.

16. 선택 정렬과 버블 정렬에 대해 설명해주시고, 코드를 작성해보세요.
- 선택 정렬은 주어진 배열이나 리스트에서 최솟값을 찾고 그 값을 맨 앞의 값과 위치를 바꿉니다. 이후 맨 앞의 값 인덱스가 하나 증가하고 다시 남은 배열에서 최솟값을 찾아 위치를 바꿉니다. 버블 정렬은 인접한 원소의 위치끼리 비교하고 조건이 맞다면 교환하는 것을 반복합니다. 이 경우 배열을 한번 순회할때마다 최댓값이 하나씩 정렬되며 순회를 반복하면서 모든 값을 정렬하게 됩니다.

```csharp
	static void Main(string[] args)
        {
            int[] Arr = new int[]{ 3, 4, 1, 5, 2 };
            int Index, temp;
 
            for (int i = 0; i < Arr.Length - 1; i++)
            {
                Index = i;
 
                for (int j = i + 1; j < Arr.Length; j++)
                {
                    if (Arr[j] < Arr[Index])
                        Index = j;
                }
                 
                if (i != Index)
                {
                    temp = Arr[i];
                    Arr[i] = Arr[Index];
                    Arr[Index] = temp;
                }
            }
 
            for (int i = 0; i < Arr.Length; i++)
                Console.Write(Arr[i] + "\t");
        }
```

```csharp
	static void Main(string[] args)
        {
            int[] Arr = new int[]{ 3, 4, 1, 5, 2 };
 
            int temp;
            int Count = 0;
            for (int i = 0; i < Arr.Length-1; i++)
            {
                for (int j = 0; j < Arr.Length - 1; j++)
                {
                    if (Arr[j] < Arr[j + 1])  
                    {
                        temp = Arr[j + 1];
                        Arr[j + 1] = Arr[j];
                        Arr[j] = temp;
                    }
                    Count++;
                }
            }
 
            Console.WriteLine("Count : {0}", Count);
 
            for(int i = 0; i < Arr.Length; i++)
                Console.Write(Arr[i] + "\t");
        }
```

17.  스택, 힙 메모리란 무엇이며 어떤 차이가 있는지 비교해서 설명해주세요.
- 스택 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다. 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되는 영역입니다. 스택은 힙에 비해 접근이 매우 빠르고 데이터를 후입선출 방식으로 관리하며 지역 변수만 저장되며 공간은 CPU에 의해 효율적으로 관리되고 메모리는 단편화되지 않습니다. 힙은 스택에 비해 접근이 좀 느리고 메모리 크기에 제한이 없으며 메모리 관리를 사용자가 직접 해야 합니다. 

18. 값 형식과 참조 형식의 차이에 대해 설명해주세요.
- 값 형식은 스택 영역에 데이터를 할당하며, 참조 형식은 힙 영역에 데이터를 할당합니다. 값 형식은 스택 메모리 영역에 데이터가 생성이 되며 값을 직접적으로 가지고 있습니다. 값 형식의 데이터는 후입선출 방식으로 관리됩니다. 참조 형식은 힙 영역에 데이터가 저장이 되고 스택 영역에서는 데이터가 저장되어 있는 힙 영역의 메모리의 주소를 저장합니다. 값 형식은 0 으로 초기화 하고 참조 형식은 Null로 초기화 할 수 있습니다.

19. 자료구조의 종류는 무엇이 있으며 각각 어떤 차이점이 있는지 설명해주세요
- 배열 : 동일한 타입의 데이터를 저장하고 고정된 크기를 가지고 있다.
- 연결 리스트 : 동적으로 데이터를 추가/삭제 할 수 있고 각 데이터가 순서를 가지고 연결된 구조를 가지고 있다.
- 스택 : 순서가 보존되는 선형 데이터 구조. 후입선출 방식으로 데이터를 관리한다.
- 큐 : 가장 먼저 입력된 요소부터 처리하는 선입선출 방식으로 데이터를 관리한다.
- 해시 테이블 : 해시함수를 사용하여 변환한 값을 인덱스로 삼아 키와 데이터를 관리하는 자료구조이다. 데이터의 크기와 관계없이 삽입과 검색에 매우 효율적이다.
- 딕셔너리 : 해시 테이블에 제네릭이 있는 구조 
- 그래프 : 노드 사이에 방향이 있는 자료구조. 화살표가 없는 방향은 양방향을 뜻한다.
- 트리 : 그래프가 계층적 구조를 가진 형태이다. 최상위 노드를 가지고 있으며 상위 노드를 부모, 하위 노드를 자식으로 표현한다.
- 힙 : 이진트리 구조를 가진 자료구조. 부모의 키 값이 자식의 키 값보다 작거나 같으면 최소 힙, 크거나 같으면 최대 힙이다.

a. 위 자료구조는 무조건 좋은가요?
- 상황에 따라 다르지만 데이터가 많아지면 무조건 알고 있는 것이 중요하다고 생각합니다. 자료구조의 정의, 구현 방법, 사용처와 알고리즘 정도만 알고 있다면 괜찮다고 생각합니다. 

20. 객체지향이란 무엇인지 설명해주세요.
- 객체 지향 프로그래밍은 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.

(꼬리질문) 객체지향의 특징은 무엇이 있나요?
- 추상화 : 객체에서 공통된 속성과 행위를 찾아 추출해서 타입을 정의하는 과정. 불필요한 정보는 숨기고 필요한 정보만 노출시켜 프로그램을 간단하게 만드는 것.
- 캡슐화 : 변수와 함수를 결합 시켜 묶고 낮은 결합도를 유지할 수 있도록 설계하는 것.
- 상속 : 클래스의 속성과 행위를 하위 클래스에 물려주거나 하위 클래스가 상위 클래스의 속성과 행위를 물려받는 것. 재사용으로 인한 코드가 줄어든다.
- 다형성 : 하나의 변수명, 함수명이 상황에 따라 다른 의미로 해석 될 수 있는 것. 어떠한 요소에 여러 개념을 넣어 놓는 것. 오버로딩과 오버라이딩이 있다.
- 오버로딩 : 같은 이름의 메서드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것.
- 오버라이딩 : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용하는 것.

(꼬리질문) OOP란?
- Object-Oriented Programming 의 줄임말로 객체 지향 프로그래밍을 뜻합니다.

(꼬리질문) SOLID 원칙은 무엇인가요?
1. 단일 책임 원칙 (SRP, Single Responsibility Principle)
하나의 클래스는 단 하나의 책임만 가져야 한다. 단일 책임 원칙을 지키지 않을 경우 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.
2. 개방-폐쇄 원칙 (OCP, Open/Closed Principle)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.
3. 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)
프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. 인터페이스 분리 원칙 (ISP, Interface Segregation Principle) 
5. 의존성 독립 원칙 : 원칙이란 객체에서 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙이다.

21. 상속이란 무엇인지 프로젝트 내에 적용해 본 부분과 함께 예를 들어 설명해주세요.
- 상속은 부모 클래스인 기준 클래스로부터 새로운 파생(자식) 클래스를 만드는 것입니다. 상속을 사용하게 되면 기준(부모) 클래스의 private를 제외한 데이터 및 메서드들을 파생클래스에서 사용할 수 있게 됩니다. 파생(자식) 클래스는 기준(부모) 클래스로부터 물려 받는 멤버들 외에 자기 고유의 메서드와 데이터를 추가해서 사용할 수 있습니다.

22. 오버로딩과 오버라이딩의 차이점을 설명해주세요.
- 오버로딩은 같은 이름의 메서드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것이고, 오버라이딩은 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용하는 것을 말합니다.

23. 인터페이스와 추상클래스의 차이를 설명해주세요.
- 인터페이스는 생성자를 선언할 수 없지만 추상 클래스는 생성자를 선언할 수 있습니다. 또한 인터페이스는 클래스의 외부 능력을 정의하는 데 사용되며 추상 클래스는 클래스의 실제 ID를 정의하는 데 사용되고 객체 또는 동일한 클래스처럼 사용됩니다. 그리고 메소드의 서명만 공유하는 경우 인터페이스를 사용할 수 있지만 구현이 필요한 경우 추상 클래스가 사용됩니다.

24. 디자인 패턴(Singleton, Observer 등) 사용하는 이유는 무엇인가요?
- 디자인 패턴을 통해 프로그램 설계에 대한 추상화를 할 수 있고 프로그래머가 프로그램을 객체 관점보다 높은 레벨에서 생각할 수 있게 해줍니다. 그래서 프로그램의 구조 파악이 쉬워지고 재사용을 통한 개발 시간 단축 그리고 유지보수에 큰 장점을 가질 수 있습니다. 또한 프로그래머끼리 소통할 때에도 구조화된 패턴에 대한 사전 지식이 있다면 시간과 비용을 절약할 수 있습니다.

(꼬리질문) 프로젝트에 디자인패턴을 적용해 본 경험이 있나요? 왜 그 디자인패턴을 선택해서 구현하였나요?
- 게임에 하나만 존재해도 무방한 게임 매니저, 사운드 매니저 같은 객체를 싱글톤 패턴을 이용해 구현한 적이 있습니다.

(꼬리질문) Unity를 사용하면서 경험해볼 수 있는 대표적인 디자인패턴이 무엇인지 설명해주세요.
- 역시 게임을 만드는 엔진이다 보니 객체를 하나만 생성해서 사용하는 싱글톤 패턴이 가장 대표적이지 않을까 생각합니다.

25. MVC 모델이란 무엇인지 설명해주세요.
- MVC 는 Model, View, Controller의 약자 입니다. 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴입니다. 사용자가 Controller를 조작하면 Controller는 Model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 됩니다. Model은 애플리케이션의 정보, 데이터를 나타내고, View는 텍스트 입력, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타냅니다. 마지막으로 Controller는 사용자가 데이터를 클릭하고 수정하는 것에 대한 이벤트들을 처리하는 부분을 뜻합니다.

26. Unity 의 생명주기(Unity Life Cycle)에 대해서 설명해주세요.
- 유니티 스크립트의 대부분은 Monobehavior 클래스를 상속받습니다. 이 클래스를 상속받은 오브젝트는 씬에 있는 동안 엔진에서 일정한 흐름에 따라 자동으로 함수를 호출하는데 이 흐름을 생명 주기 라고 합니다. 자주 사용하는 함수들의 호출 순서는 Awake - OnEnable - Start - FixedUpdate - OnTrigger~~~ - OnCollision~~~ - Update - LastUpdate - OnApplicationQuit - OnDisable - OnDestroy 입니다.
![다운로드](https://github.com/dlghdwns97/Study/assets/73785455/c322a1c6-b699-43d3-8b5d-7c06f6109d4d)

27. MonoBehaviour 클래스의 주요 메서드와 그 기능에 대해 설명해주세요.
- MonoBehaviour 클래스에는 유니티에서 많이 사용하는 함수가 들어 있습니다. Awake, Start, Update, OnCollision~~~, OnTrigger~~~, GetComponent 등 게임 오브젝트와 관련된 생명 주기 함수들이 모두 들어 있습니다.
- Awake : 스크립트가 실행될 때 1번만 호출됩니다. 오브젝트의 초기화 또는 프리팹의 인스턴스화가 모두 진행된 직후에 호출됩니다.
- Start : 스크립트가 활성화될 때 1번만 호출됩니다.
- FixedUpdate : 고정된 프레임 주기로 호출됩니다.
- Update : 매 프레임마다 호출되는 함수로 디바이스 성능이나 최적화 상황에 따라 framerate가 변하므로 함수 호출 시간이 매번 달라집니다.
- OnTrigger~~~ : 두 오브젝트의 충돌 체크를 하는 함수. 콜라이더의 is Trigger 가 체크되어 있어야 함. 물리엔진 계산을 하지 않습니다.
- OnCollision~~~ : Rigidbody가 존재하는 오브젝트의 충돌 체크를 하는 함수. 물리엔진 계산을 해야하기 때문에 Rigidbody가 존재해야 합니다.
- OnEnable : 오브젝트가 활성화 될 때 호출됩니다. 이벤트 시작 함수로 사용합니다.
- OnDisable : 오브젝트가 비활성화 될 때 호출됩니다. 이벤트 종료 함수로 사용합니다.
- OnDestory : 오브젝트 생존 기간의 마지막 프레임이 업데이트된 후 실행됩니다.

28. Unity 오브젝트가 다양하게 씬에 올라와 있다면 동시에 시작되고 무엇이 먼저 초기화 되는지 알 수 없을 수 있는데, 프로젝트에서 코드를 만들 때 이에 대해 고민하고 해결해본 경험이 있다면 설명해주세요.
- 저는 예전에 스크립트에서 게임 오브젝트 컴포넌트를 받아오기 위해 Public으로 게임 오브젝트를 선언하고 Awake 함수에 GetComponent를 사용한 뒤 인스펙터 창에서 오브젝트를 끌어다가 쓴 경우가 많습니다. 이런 경우에 Awake에서 게임오브젝트를 받아오지 못하고 널 레퍼런스 오류가 자주 떴었는데 Awake에서 GetComponent를 사용하지 않고 사용해보니 오류가 뜨지 않았습니다. 무분별한 Awake, Start, GetComponent 사용이 마냥 좋지 않다는 것을 깨달은 경험이었습니다.

29. Update의 종류와 각각 어떤 특징을 가지고 있는지 설명해주세요.
- Update는 FixedUpdate, Update, LateUpdate 3종류가 있습니다. FixedUpdate는 고정된 프레임 주기(기본 0.02초)로 호출되고 Update는 매 프레임마다 호출되지만 디바이스 성능이나 최적화 상황에 따라 Framerate가 변하므로 함수 호출 시간이 매번 달라집니다. LateUpdate는 모든 Update 함수가 호출된 후 가장 마지막으로 호출됩니다.

30. 서로 다른 성능을 가진 기기에서 Update 사용 시 주의할 점에 대해 설명해주세요.
- 디바이스 성능이 다를 경우 Update를 사용하면 서로 호출 시간이 달라질 수 있습니다. 예를 들면 모니터 주사율이 서로 다른 컴퓨터라면 같은 Update 함수여도 어떤 컴퓨터는 60분의 1초에 한번, 다른 컴퓨터는 144분의 1초에 한번 실행될 수 있습니다. 이를 방지하려면 FixedUpdate를 사용하거나 프레임을 화면 주사율로 일정하게 고정시켜주는 VSync 기능을 사용해야 합니다.

31. 유니티로 타이머를 구현하는 알고리즘을 설명해주세요.
- 첫번째로 time 전역변수를 선언한 뒤 Update 에서 Time.deltaTime 를 계속 더해주어 time을 ToString() 을 이용해 표현해주는 방법이 있습니다. 두번째로는 Time.deltaTime 을 더해주고 화면에 표시해주는 코루틴을 만들어 사용하는 방법이 있습니다. 코루틴도 동기로 작동하기 때문에 타이머를 구현할 수 있습니다.

32. Time.deltaTime이란 무엇이며, 사용하는 이유에 대해 설명해주세요.
- Time.deltaTime 은 한 프레임 당 실행하는 시간을 float 타입으로 나타낸 값입니다. 모든 게임은 fps (frame per second)가 존재하는데 이는 1초에 화면에 게임이 몇번 그려지는지 수치로 표현한 것입니다. 만약 성능이 다른 두 컴퓨터가 각기 다른 fps로 같은 프로그램을 실행한다면 게임 환경에 큰 영향을 미치게 됩니다. 이를 방지하기 위해서 Time.deltaTime 을 이용해 결과값을 보정해줘야 합니다. 예를 들면 30fps 게임의 경우 Time.deltaTime 이 0.03초 이고 60fps일 경우 0.016초를 가지게 되며 이를 프레임에 보정시켜주면 다른 fps로 작동하는 게임도 모두 동일한 환경처럼 동작할 수 있게 됩니다.

33. 유니티 렌더링 파이프라인에 대해 설명해보세요.
- 유니티 렌더링 파이프라인은 3D 데이터를 화면에 표현하기 위해 2D 이미지로 렌더링 하는 과정을 뜻합니다. 먼저 버텍스 쉐이더에서 버텍스 연산을 합니다. 위치 변환, 스키닝 등 가공을 거쳐 버텍스 정보로 출력됩니다. 그 다음 테셀레이터에서 연산된 버텍스 정보로 폴리곤을 늘려줍니다. 그리고 지오메트리 쉐이더에서 각 버텍스마다 특정한 연산을 통해 폴리곤을 추가로 생성합니다. 이전 단계의 버텍스 정보를 기반으로 가공하여 새로운 폴리곤을 구성하여 출력합니다. 그 이후 레스터라이저에서 3D 폴리곤을 2D 픽셀로 변환, 보간한 뒤 3D 오브젝트의 앞 뒤를 설정합니다. 안 보일 곳까지 결정된 뒤에 프래그먼트 쉐이더에서 래스터화된 픽셀마다 어떤 색이 들어갈지 계산합니다. 마지막으로 Output Merger 에서 블랜드 방식을 결정한 뒤 최종 렌더링 타켓에 그려넣고 포스트 프로세싱 연산 이후 화면에 출력시킵니다.

(꼬리질문) 랜더링 파이프라인에는 어떤 종류가 있나요?
- 먼저 유니티의 기본 렌더링 파이프라인인 SRP(Scriptable Render Pipeline)이 있습니다. SRP는 C# 스크립트로 제어할 수 있는 기능이며 유니티에 기본적으로 구현되어 있습니다. 두번째로 URP(Universal Render Pipeline)가 있습니다. URP는 SRP보다 유연하고 확장성이 좋으며 다양한 플랫폼에 최적화된 그래픽을 제공합니다. 싱글 패스 포워드 렌더링과 쉐이더 그래프, VFX 그래프를 지원합니다. 세번째로 HDRP(High Definition Render Pipeline)이 있습니다. HDRP는 하이엔트와 PC, 콘솔 등을 고려해 고품질의 비주얼 구현에 적합한 파이프라인입니다. 포워드 렌더링, 디퍼드 렌더링을 모두 지원하며 컴퓨터 쉐이더 기술과 GPU 하드웨어를 사용합니다.

34. 드로우콜(Draw Call) 배칭이 무엇인지 설명해주세요.
- 드로우콜은 CPU가 GPU에게 렌더링하라고 명령을 내리는 것을 말합니다. 이 명령이 GPU가 사용하는 신호로 변환되어야 하는데 여기서 CPU에 부담이 가고 병목현상이 발생하게 됩니다. 오브젝트가 메쉬를 1개 가지고 있다면 드로우콜이 1번 발생하지만 만약에 10개의 메쉬를 가지고 있다면 드로우콜이 10번 발생하게 됩니다. 이렇게 드로우콜 횟수가 커지면 성능에 많은 영향을 끼치게 되는데 이런 현상을 방지하기 위해 배칭을 사용합니다. 배칭은 여러번의 드로우콜을 하나의 드로우콜로 묶는 과정입니다. 다른 오브젝트, 메쉬를 사용하더라도 메테리얼이 같다면 하나의 배치로 묶을 수 있습니다. 이 말은 배칭을 위해서는 하나의 텍스처를 여러 메쉬들이 공유해서 사용해야 한다는 뜻입니다. 그래서 텍스처 하나에 여러 텍스처를 합쳐서 사용하는 텍스처 아틀라스 기법으로 리소스를 제작하게 됩니다. 배칭에는 정적 배칭과 동적 배칭이 있습니다. 정적 배칭은 배경 오브젝트같이 정적인 오브젝트를 위한 배칭 기법입니다. 인스펙터에서 Static을 체크하면 로딩타임에서 자동으로 배칭처리를 해주며 처음부터 씬에 존재해야 합니다. 나중에 추가되는 정적 오브젝트를 배칭하는 방법도 있지만 데이터를 수집하고 메시를 재생성해야 하기 때문에 사용을 자제하는 것이 좋습니다. 동적 배칭은 Static이 체크되지 않은 동적인 오브젝트들 중 동일한 메테리얼을 사용하고 특정 조건을 만족하는 오브젝트들을 대상으로 배칭처리를 하는 기능입니다. Dynamic Batching을 체크해주면 별도의 추가 작업 없이 정적 배칭처럼 알아서 배칭 처리를 해줍니다. 하지만 매번 데이터 구축과 갱신이 발생하기 때문에 매 프레임마다 오버헤드가 발생해서 제약사항이 많습니다.

35. 코루틴(Coroutine)이 무엇이며, 어떤 상황에서 유용하게 사용될 수 있나요?
- 코루틴은 실행을 일시 정지하고 제어를 Unity에 반환하지만 중단한 부분에서 다음 프레임을 계속할 수 있는 메서드입니다. 코루틴을 사용하면 작업을 다수의 프레임에 분산할 수 있습니다. 동기로 작동하는 함수이지만 비동기 작업을 처리하는 것처럼 사용할 수 있어서 시간의 경과에 따른 명령을 주고 싶을 때 사용하면 유용합니다. 하지만 병렬처리로 작업을 하진 않습니다.

(연관질문) 코루틴을 사용한 경험에 대해 설명해주세요.
- 저는 벽돌깨기 게임에서 아이템의 효과를 구현할 때 사용해본적이 있습니다. 아이템을 먹는 순간 12초동안 효과를 지니다가 지속시간이 끝나면 코루틴을 종료하는 식으로 아이템을 구현했습니다.

36. 오브젝트 풀링(Object Pooling)이 무엇이며, 어떻게 구현하는지 설명해주세요.
- 오브젝트 풀링은 미리 오브젝트의 풀을 만들어 두고 필요할때마다 오브젝트를 꺼내서 사용하는 것을 말합니다. 오브젝트 풀링을 담당하는 스크립트를 만들고 미리 사용할 오브젝트를 일정량 생성해 놓습니다. 그리고 그 스크립트에 생성해놓은 오브젝트를 필요에 따라 가져다 사용하는 메서드, 모자를 때 더 생성하는 메서드, 다 사용한 뒤 반환하는 메서드, 필요에 따라 파괴하는 메서드 등을 추가하면 Instantiate와 Destory의 사용 빈도를 획기적으로 줄일 수 있습니다.

37. Object pool을 사용하는 이유는 무엇인가요?
- Instantiate, Destroy 두 함수의 사용 빈도를 줄이기 위해서 입니다. 특히 Destroy는 게임오브젝트를 제거 할때 참조를 끊어버리고 가비지 상태로 만드는데 이 경우 가비지 컬렉터가 수집하기 전까지 불필요한 메모리를 계속 차지하게 됩니다. 이 가비지가 계속 쌓이면 가비지 컬렉터가 불러지게 되고 프레임 드랍이 일어나게 됩니다. 결과적으로 최적화를 위해 사용한다고 할 수 있습니다.

38. 객체를 이동할 때 벡터를 정규화(Nomarlized) 하는 이유에 대해 설명해주세요.
- 벡터는 좌표와 크기(속도)를 모두 담고 있는 정보입니다. 벡터를 정규화하지 않는다면 대각선 이동이 직선 이동보다 더 빨라진다거나 같은 방향을 보고 있는 벡터끼리도 크기가 달라질 수 있습니다. 그래서 객체의 이동과 방향에 벡터를 사용할 떈 벡터를 정규화 시켜 단위 벡터로 만들어준 뒤 사용해야 합니다.

39. 월드 스페이스(World Space)와 로컬 스페이스(Local Space)의 차이에 대해 설명해주세요.
- 월드 스페이스는 게임 세상을 기준으로 하는 절대적인 좌표축이고 로컬 스페이스는 오브젝트의 부모 또는 회전을 기준으로 하는 상대적인 좌표축입니다. 빈 오브젝트를 부모로 둔 구가 하나 있다고 가정하고 이 구가 0, 0, 0의 로컬 좌표를 가질 때 빈 오브젝트를 움직이게 되면 구의 위치도 같이 변합니다. 이 경우에 빈 오브젝트와 구의 절대 좌표는 모두 변했지만 구의 로컬 좌표는 변하지 않습니다. 구의 로컬 좌표는 빈 오브젝트를 따라가는 상대적인 좌표이기 때문입니다.

40. 컬링 종류와 사용하는 이유에 대해 설명해주세요.
- 컬링이란 최적화를 위해 눈에 보이지 않는 오브젝트를 렌더링에서 추려내는 것을 말합니다. 컬링에는 프러스텀 컬링, 오클루전 컬링 두 종류가 있습니다. 프러스텀 컬링은 유니티 엔진에서 기본적으로 수행하는 컬링입니다. 카메라의 사다리꼴 영역 안에 들어오거나 걸친 오브젝트만 렌더링하고 나머지 오브젝트는 모두 제외시키는 컬링 방식입니다. 오클루전 컬링은 다른 오브젝트에 가려진 오브젝트들은 렌더링하지 않는 컬링 방식입니다. 오브젝트를 가리는 역할을 하는 오브젝트에게 Occluder Static 설정을 넣고 Occluder 에 의해 가려지는 오브젝트에겐 Occludee Static 설정을 넣어 사용할 수 있습니다. Static 에서 알 수 있듯이 오클루전 컬링의 대상이 되는 오브젝트들은 모두 정적인 오브젝트여야 합니다.

41. 유니티 최적화 기법은 어떤 것들이 있나요?
- 우선 새로운 오브젝트를 생성하지 않고 기존 오브젝트를 재사용하는 오브젝트 풀링이 있습니다. 또한 배칭을 위해 여러 개체를 하나로 묶어 렌더링하거나 배경 오브젝트 같은 것들을 정적 배칭으로 합칠 수도 있습니다. 여러 텍스처를 하나의 텍스처로 합치는 텍스처 아틀라스 기법도 있습니다. 스크립트 간에 공유할 수 있는 재사용 가능한 데이터 오브젝트를 생성하고 필요할 때 마다 읽어와 세팅하는 스크립터블 오브젝트 방식도 있습니다.

    1. 최적화를 해본 적이 있나요? 없다면 어떤 최적화가 있는지 설명해주세요.
	- 저는 맵의 배경 오브젝트를 정적 배칭으로 묶고 각 개체들을 하나의 메쉬로 묶어본 적이 있습니다. 그리고 끊임없이 몬스터가 나오고 사라지는 것에 오브젝트 풀링을 사용해본 적이 있습니다.

    2. 최적화에서 가장 중요한 부분은 무엇인가요?
	- 가장 중요한 부분은 메모리를 가장 적게 사용하도록 만드는 것이라고 생각합니다. 불필요한 할당과 제거를 줄이고 가비지 컬렉터를 사용할 때도 메모리 사용량을 최소화 시키는 것이 중요하다고 생각합니다.

    3. 최적화를 위해서 적용해본 텍스쳐 포맷이 있나요?


43. 가비지컬렉터(GC)란 무엇인가요?
- 가비지 컬렉터는 필요없는 동적 메모리를 해제하는 C#의 자동 메모리 관리 기능입니다. 가비지 컬렉터는 프로그램을 실행하다가 특정한 타이밍에 현재 할당된 메모리를 조사해서 그것이 현재 접근 가능한 상태인지 불가능한 상태인지 분류한 뒤 접근이 불가능한 메모리를 쓰레기로 간주하여 해제시킵니다. 하지만 모든 메모리를 조사하는건 실시간으로 동작하는 프로그램에서 끊기는 현상을 유발할 수 있기 때문에 요즘은 점진적으로 여러번에 걸쳐서 수행하는 방식을 사용하는 것으로 알고 있습니다.

43. 어떤 에셋을 사용해 보셨나요? 없다면 알고 있는 에셋이 있나요?
- 저는 맵을 만들 때 큐브모양의 지형 에셋을 사용해보았고 다수의 큐브를 이용해 지형을 만들 때 개별로 존재하는 메쉬들을 하나로 합쳐주는 메쉬 베이크 에셋을 사용해 본 적이 있습니다. 이 외에도 캐릭터, 파티클 등 다양한 에셋이 존재하는 것으로 알고 있습니다.

44. ScriptableObject이란 무엇이며 어떻게 사용되나요?
- ScriptableObject 는 유니티 오브젝트를 상속받은 클래스로 MonoBehaviour 보다 경량화된 데이터 컨테이너를 말합니다. 스크립트를 만들 때 MonoBehaviour 대신 ScriptableObject 를 상속받게 한 뒤 다른 오브젝트가 참조할 값을 선언하면 사용할 수 있습니다.

    1. ScriptableObject의 특징에 대해 설명해주세요.
	- 우선 게임 오브젝트에 ADD해서 사용할 수 없습니다. 그리고 유니티 콜백 중 OnEnable, OnDisable, OnDestory 만 받을 수 있으며 ScriptableObject 의 내용을 변경하면 참조하는 모든 곳에서 동일한 값으로 반영됩니다. 프리팹을 100번 사용하는데 모두 동일한 데이터를 사용한다면 같은 프리팹을 100번 할당하는 것 보다 100개의 오브젝트가 1개의 ScriptableObject를 참조해 메모리 사용량을 획기적으로 줄일 수 있습니다.

45. Unity에서 레이어와 태그의 역할은 무엇이며, 어떻게 사용되는지 설명해주세요.


46. Find 함수 사용을 자제해야 하는 이유에 대해 설명해주세요.


47. Scene Load의 종류를 비교해서 설명해주세요.


48. Unity의 물리 엔진은 어떻게 동작하며, 어떤 요소를 조작할 수 있는지 설명해주세요.


49. Texture 와 Sprite 에 대해 설명해주세요.


50. 프리팹(Prefab)이란 무엇이며, 어떻게 사용되나요?


51. 디버깅을 어떤 방식으로 진행하는지 설명해주세요.


52. Attribute를 사용한 경험과 그에 대한 설명을 해주세요.


53. git을 사용해 본적이 있나요? 어떤 점이 어려웠고 어떤 툴을 사용했는지 설명해주세요.


54. 게임 개발 학습 과정에서 자신이 가장 재미있었던 부분이나 혹은 자신 있게 설명할 수 있는 부분이 있다면 설명해주세요.


55. 포트폴리오에서 본인이 담당한 부분이 무엇인가요?


56. 만약 본인이 개발한 것을 다시 개발한다면, 어떻게 개선할 것인지 설명해주세요.


57. 협업하면서 가장 어려웠던 점이 무엇인가요?
    1. 구현 하면서 기술적으로 어려웠던 부분을 어떻게 해결하였나요? 


58. 프로젝트를 진행하면서 기술적인 도전과제는 무엇이었나요?


59. 협업하면서 조원과 트러블이 있었는지?
어떻게 해결해 나갔는지


60. Git Repository를 팀원들과 공동으로 작업하면서 발생했던 문제점이 있다면 무엇인지, 어떻게 해결하였는지 이야기해주세요.
