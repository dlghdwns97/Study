1. float와 int의 표현 가능한 수의 범위가 다른 이유는 무엇인가요?
- 둘 다 같은 4바이트 자료형이지만 int형은 있는 그대로의 비트를 보여주고 float형은 부호를 표현하는 비트, 자릿수를 표현하는 비트, 값을 표현하는 비트 3부분으로 나뉘어서 그렇습니다.

2. ref와 out 사용 시 차이는 무엇인가요?
- ref를 사용하면 함수 바깥에 있는 인자를 함수로 넘겨주는 형태로, out을 사용하면 함수 내에서 정의한 값을 바깥으로 넘겨주는 형태로 작동합니다. 그래서 out을 이용한 함수는 함수 바깥에 있는 변수에 값을 할당 할 필요가 없지만 ref를 이용한 함수는 바깥에 있는 변수에 값을 할당해주지 않으면 에러가 발생합니다.

3. 접근제한자란 무엇이며, 각각 어떤 차이가 있는지 비교해서 설명해주세요.
- 접근제한자는 외부로부터 타입 또는 그 멤버들로의 접근을 제한할 때 사용하는 것으로 4종류가 있습니다. public은 모든 외부에서 이 타입에 접근할 수 있습니다. private는 동일 클래스나 구조체 내의 멤버만 접근 가능합니다. protected는 상속 클래스와 선언 클래스에서만 접근 가능합니다. internal은 동일한 같은 프로젝트 같이 어셈블리 내에 있는 다른 타입들만 접근할 수 있습니다. 접근제한자를 사용하지 않으면 기본적으로 internal 이 붙습니다.

- ![img](https://github.com/dlghdwns97/Study/assets/73785455/9898f6f7-3b95-42ae-aa98-75506ab5d854)

4. struct와 class를 비교해서 설명해주세요.
- 구조체는 상속이 불가능하고 값 타입이지만 클래스는 상속이 가능한 참조 타입입니다. 구조체는 스택이라는 메모리 영역에 할당되고 클래스는 힙에 할당하는 값의 주소를 가지고 있습니다. 그래서 사용을 할 때 구조체의 변수는 이미 스택에 할당되어 있어서 바로 불러와 사용이 가능하지만 클래스는 new 키워드를 통해 힙 영역에 할당한 뒤 그 주소값을 참조해야 합니다. C# 의 경우 가비지 컬렉터가 힙에 할당된 메모리 중 사용하지 않는 부분을 정리해주는데 이때 처리해야할 양이 많다면 프로그램이 느려지게 됩니다. 그래서 굳이 힙에 할당하지 않아도 되는 정보의 경우 스택 메모리에서 사용하면 사용 후 바로 종료가 되기 때문에 프로그램 속도 향상에 도움이 될 수 있습니다.

5. 가비지 컬렉터에 대해 설명해주세요.
- 가비지 컬렉터는 필요없는 동적 메모리를 해제하는 C#의 자동 메모리 관리 기능입니다. 가비지 컬렉터는 프로그램을 실행하다가 특정한 타이밍에 현재 할당된 메모리를 조사해서 그것이 현재 접근 가능한 상태인지 불가능한 상태인지 분류한 뒤 접근이 불가능한 메모리를 쓰레기로 간주하여 해제시킵니다. 하지만 모든 메모리를 조사하는건 실시간으로 동작하는 프로그램에서 끊기는 현상을 유발할 수 있기 때문에 요즘은 점진적으로 여러번에 걸쳐서 수행하는 방식을 사용하는 것으로 알고 있습니다.

6. 가비지 컬렉터를 회피하기 위한 전략은 무엇이 있나요?
- 우선 첫번째로 메모리 할당을 최소화시키면 됩니다. 변수를 재사용한다던가 하는 방법으로 할당을 최소화하면 가비지컬렉터의 동작빈도를 줄일 수 있습니다. 두번째로는 가비지컬렉션 메소드를 직접 호출하는 빈도를 줄이고 정말 필요한 경우에만 직접 호출하는 방법이 있습니다. 세번째로는 굳이 참조 타입이 필요하지 않다면 값 타입을 사용하는 방법이 있습니다. 하지만 이 경우에는 코드의 유지보수성이나 최적화에 문제가 될 수 있으므로 실제로 가비지컬렉터가 성능저하를 일으킬 때가 아니면 남발하지 않는 것이 좋다고 생각합니다.

추가 )
IDisposable 인터페이스 사용
IDisposable 인터페이스를 구현한 클래스는 Dispose()메서드를 호출함으로써 자체적으로 리소스를 해제할 수 있다.
이 방법을 통해 가비지 컬렉터가 처리해야 할 작업을 줄일 수 있다.

using (var resource = new DisposableResource()) // IDisposable 인터페이스를 구현한 클래스
{
	resource.Use();
} // using 블록이 끝나면 Dispose() 메서드가 자동으로 호출됨
https://learn.microsoft.com/ko-kr/dotnet/api/system.idisposable?view=net-7.0

Finalizer 사용 최소화
FInalizer는 객체가 가비지 컬렉션에 의해 수거되기 전 호출되는 특수 메서드이다.
Finalizer를 사용하면 가비지 컬렉션의 프로세스가 느려질 수 있으므로, 꼭 필요한 경우에만 사용하는 것이 좋다.

public class ClassWithoutFinalizer
{
	// Finalizer 없음.
}
https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/classes-and-structs/finalizers

7. 가비지 컬렉션이란 무엇인지 설명해주세요.
- 메모리 관리 방법중 하나로 프로그래머가 동적으로 할당한 메모리 영역 중 더 이상 쓰이지 않는 영역을 자동으로 찾아 해제하는 기능입니다. 가비지 컬렉터라는 소프트웨어가 이 기능을 담당하고 있습니다.

8. 박싱과 언박싱에 대하여 설명해주세요.
- 박싱은 값 타입의 개체를 참조 타입으로 변환하는 작업을 말합니다. 언박싱은 반대로 참조 타입으로 있는 개체를 값 타입으로 변환하는 작업을 말합니다.
```csharp
int a = 10;
object b = a; // 박싱
int c = (int)b; // 언박싱
```
(꼬리질문) 박싱, 언박싱을 사용할 때 주의해야 할 점이 있다면 무엇이 있나요?
- 일단 두 작업 모두 스택에서 힙으로 복사, 힙에서 스택으로 복사하는 과정이 추가되기 때문에 리소스를 더 사용하게 됩니다. 그래서 정말 필요한 경우가 아니면 사용하지 않는 것이 좋고 특히 언박싱은 기존과 다른 타입으로 언박싱 하거나 해당 타입보다 작은 범위로 변환을 하면 에러가 호출되기 때문에 is 연산자를 사용해서 미리 같은 타입인지 캐스팅 해보는 작업이 필요합니다.

9. 배열과 List, ArrayList, Dictionary 의 차이점을 설명해주세요.
- 배열은 크기가 고정되어 있는 동일한 타입의 원소 집합입니다. 고정된 크기를 가지고 있어 메모리 효율이 좋고 배열을 구성하는 원소에게 접근이 용이하지만 크기 변경이 불가능하고 데이터를 자주 바꿔야하는 경우엔 알맞지 않습니다. 리스트는 크기가 동적인 동일한 타입의 원소 집합입니다. 원소를 추가하거나 제거하는 경우가 잦다면 배열보다는 리스트를 사용하는 것이 좋습니다. ArrayList는 크기가 동적인 모든 타입의 원소 집합입니다. 리스트와 마찬가지로 원소를 추가하거나 제거하는 경우가 잦을 때 사용하며 모든 타입의 원소를 저장할 수 있습니다. 하지만 제네릭이 없어 타입 안정성은 떨어집니다.(잘못된 데이터를 추가할 수 있음) 딕셔너리는 키와 값의 쌍으로 이루어진 집합입니다. 키를 통해 값을 찾거나 데이터 간의 연관성을 직관적으로 보여줘야 할 때 사용합니다. 키 값은 중복값을 가질 수 없습니다.

(꼬리질문) Dictionary는 어떻게 구현해야 하나요?
- 딕셔너리는 해쉬 테이블 기반으로 구현되어 있습니다. 해쉬는 특정 키를 해쉬 함수를 통해 해쉬 테이블의 주소값으로 변경합니다. 그리고 그 해쉬 함수가 값이 저장될 위치를 가리키고 해당 위치에 값이 저장됩니다.

(꼬리질문) Dictionary 검색이 빠른 이유는 무엇인가요?
- 저장할 때 key 값에 해쉬 함수를 적용해 고유한 index 를 만들어 저장하기 때문입니다. key 를 알면 해쉬 함수를 통해 바로 index 를 알 수 있으므로 데이터를 찾을 때 O(1) 의 평균 시간복잡도로 조회, 삭제가 가능합니다.

### List
C#에서 List가 동적으로 크기를 정할수 있기 때문에 노드 방식으로 생각하고 계신 분들이 계신데 내부적으로는 배열로 구현되어 있습니다.
List<int> myList = new List<int>();
리스트를 만들면 내부적으로는 배열을 미리 생성을 해둡니다.
이때 만들어지는 기본 배열의 0개 짜리입니다.
내부 배열 - [   ]
myList.Add(10);
이후 데이터를 추가하게 되면 배열이 비어있는지 아닌지 체크를 합니다.
비어다면 기본 용량만큼 배열을 새로 만들어줍니다.
(TMI - 기본 용량는 구현체 마다 다르지만 C# 에서는 기본적으로 4개짜리 배열을 생성하게 됩니다.)
내부 배열 - [10][   ][   ][   ]
myList.Add(20);
myList.Add(30);
myList.Add(40);
데이터를 추가하면 배열이 남아 있으면 계속 해서 채워 나갑니다.
내부 배열 - [10][20][30][40]
myList.Add(50);
배열이 꽉찬 상태에서 데이터를 추가하면 배열 사이즈의 2배만큼 새로운 배열을 만듭니다.
이때 기존 배열과 완전히 다른 새로운 배열을 만들어서 데이터를 옮기게 됩니다.
이말은 기존 배열은 아직 유지되어 있는 상태이고 이후 CG의 대상이 됩니다.
내부 배열 - [10][20][30][40][50][   ][   ][   ]       <- 새로 생긴거
기존 배열 - [10][20][30][40]                              <- 이전에 쓰던거 (GC 의 대상)
이렇게 사용해다가면 데이터를 계속 추가를 할때마다 새로운 배열을 만들게 됩니다.
숫자가 가늠이 된다면 List 를 사용하실때도 대략적인 사이즈를 지정해 주신다면 처음 배열을 만들때 내부 배열의 사이즈를 조정할 수 있습니다.
이렇게 된다면 배열을 옮김으로서 생기는 부하를 방지할 수 있습니다.
List<int> myList = new List<int>(10);
내부 배열 - [   ][   ][   ][   ][   ][   ][   ][   ][   ][   ]
결론
리스트는 내부적으로 배열이다.
리스트도 가능하면 배열 크기를 먼저 정해주면 부하를 줄일 수 있다.
리스트의 삽입/삭제시 내부적으로 배열 중간의 데이터를 추가/지우고 다른 데이터를 옮겨야 하기 때문에 성능은 O(n) 이 됩니다. (주의 - 사용이 한번에 된다고 O(1) 이 아닙니다)
리스트 내부 데이터는 메모리에 연속적으로 할당됩니다.(배열이기 때문에)
List 와 Linked List 는 다릅니다.
간략하게 텍스트로 공유드리니 해당 내용 한번 학습해보시면 좋을것같습니다.
아마 List 와 Linked List 의 내용을 혼동하셔서 잘못 작성하신 분들이 계시는것같습니다.
구조를 완벽히 알 필요는 없지만 대략적인 동작원리는 파악하시면 도움이 됩니다.

10. 제네릭이란 무엇인가요?
- 제네릭은 데이터 형식을 지정하지 않고 형식 매개변수로 전달해서 클래스를 정의하는 것을 말합니다. 제네릭을 사용할 경우 데이터 형식별로 클래스를 생성하지 않아 재사용성, 안전성 등을 최대화 할 수 있습니다.
```csharp
using System;

namespace Project
{
    class Program
    {
        static void Main(string[] args)
        {
            GenericQueue<int> intData = new GenericQueue<int>(100);

            intData.Enqueue(100);
            intData.Enqueue(200);
            intData.Enqueue(300);

            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());

            intData.Enqueue(400);
            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());
        }   
    }

    class GenericQueue<T>
    {
        public T[] array;
        private int count = 0;

        public GenericQueue(int length)
        {
            array = new T[length];
        }

        public void Enqueue(T value)
        {
            array[++count] = value;
        } 

        public T Dequeue()
        {
            return count == 0 ? default(T) : array[count--];
        }
    }
}
```

11. 델리게이트(Delegate)의 개념에 대해 설명해주세요.
- 델리게이트는 메서드에 대한 참조를 갖는 형식입니다. 여러 메서드를 등록해 한번의 호출로 등록된 모든 메서드를 호출할 수 있습니다.

12. 'delegate', 'event', 'action', 'func' 간의 차이를 설명해주세요.
- 델리게이트, 액션, func는 일단 모두 델리게이트와 같은 대리자 형태를 가지고 있습니다. 가장 기본적인 형태가 델리게이트이고 action과 func는 C# 내부적으로 정의하고 있는 대리자 입니다. action은 인자만 존재하는 대리자, func은 인자와 결과 값이 모두 존재하는 대리자입니다. 이벤트는 대리자를 오직 변수를 선언한 클래스 내부에서만 쓸 수 있게해주는 키워드 입니다. 이벤트는 클래스 내부에서만 실행할 대리자니 다른 곳에서 사용하지 못하게 하라고 컴파일러에 명시적으로 알려주는 기능을 합니다.

(꼬리질문) 프로젝트에 적용해 본 경험이 있다면 설명해주세요.
- 아직 없..네

13. 람다식(Lambda Expression)이 무엇인지 설명해주세요.
- 람다식은 무명 함수를 표현하는데 사용됩니다. 연산자로는 => 를 사용하며 연산자 왼쪽에 입력 파라미터를, 연산자 오른쪽에 실행할 문장 블럭을 입력합니다. 람다식을 이용하면 델리게이트를 더 간편하게 표현할 수 있습니다.

14. 콜백이란 무엇인가요? 사용해봤는지?
- 콜백은 피호출자가 호출자를 다시 호출하는 것으로 비동기 처리가 많을 때 유용하게 사용됩니다. 콜백에는 객체를 전달하지 않고 메서드를 담아 전달해 사용할 수 있는 델리게이트가 많이 사용됩니다.

15. 정렬 알고리즘이란 무엇이며, 사용 이유에 대해 설명해주세요.
- 어떤 데이터 집합을 정해진 순서대로 나열하는 것을 말합니다. 데이터를 정렬하는 이유는 탐색을 위해서이고 그중에서도 이진 탐색이라는 아주 강력한 알고리즘을 사용하기 위해서 정렬을 사용합니다.

16. 선택 정렬과 버블 정렬에 대해 설명해주시고, 코드를 작성해보세요.
- 선택 정렬은 주어진 배열이나 리스트에서 최솟값을 찾고 그 값을 맨 앞의 값과 위치를 바꿉니다. 이후 맨 앞의 값 인덱스가 하나 증가하고 다시 남은 배열에서 최솟값을 찾아 위치를 바꿉니다. 버블 정렬은 인접한 원소의 위치끼리 비교하고 조건이 맞다면 교환하는 것을 반복합니다. 이 경우 배열을 한번 순회할때마다 최댓값이 하나씩 정렬되며 순회를 반복하면서 모든 값을 정렬하게 됩니다.

```csharp
	static void Main(string[] args)
        {
            int[] Arr = new int[]{ 3, 4, 1, 5, 2 };
            int Index, temp;
 
            for (int i = 0; i < Arr.Length - 1; i++)
            {
                Index = i;
 
                for (int j = i + 1; j < Arr.Length; j++)
                {
                    if (Arr[j] < Arr[Index])
                        Index = j;
                }
                 
                if (i != Index)
                {
                    temp = Arr[i];
                    Arr[i] = Arr[Index];
                    Arr[Index] = temp;
                }
            }
 
            for (int i = 0; i < Arr.Length; i++)
                Console.Write(Arr[i] + "\t");
        }
```

```csharp
	static void Main(string[] args)
        {
            int[] Arr = new int[]{ 3, 4, 1, 5, 2 };
 
            int temp;
            int Count = 0;
            for (int i = 0; i < Arr.Length-1; i++)
            {
                for (int j = 0; j < Arr.Length - 1; j++)
                {
                    if (Arr[j] < Arr[j + 1])  
                    {
                        temp = Arr[j + 1];
                        Arr[j + 1] = Arr[j];
                        Arr[j] = temp;
                    }
                    Count++;
                }
            }
 
            Console.WriteLine("Count : {0}", Count);
 
            for(int i = 0; i < Arr.Length; i++)
                Console.Write(Arr[i] + "\t");
        }
```

17.  스택, 힙 메모리란 무엇이며 어떤 차이가 있는지 비교해서 설명해주세요.
- 스택 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다. 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되는 영역입니다. 스택은 힙에 비해 접근이 매우 빠르고 데이터를 후입선출 방식으로 관리하며 지역 변수만 저장되며 공간은 CPU에 의해 효율적으로 관리되고 메모리는 단편화되지 않습니다. 힙은 스택에 비해 접근이 좀 느리고 메모리 크기에 제한이 없으며 메모리 관리를 사용자가 직접 해야 합니다. 

18. 값 형식과 참조 형식의 차이에 대해 설명해주세요.
- 값 형식은 스택 영역에 데이터를 할당하며, 참조 형식은 힙 영역에 데이터를 할당합니다. 값 형식은 스택 메모리 영역에 데이터가 생성이 되며 값을 직접적으로 가지고 있습니다. 값 형식의 데이터는 후입선출 방식으로 관리됩니다. 참조 형식은 힙 영역에 데이터가 저장이 되고 스택 영역에서는 데이터가 저장되어 있는 힙 영역의 메모리의 주소를 저장합니다. 값 형식은 0 으로 초기화 하고 참조 형식은 Null로 초기화 할 수 있습니다.

19. 자료구조의 종류는 무엇이 있으며 각각 어떤 차이점이 있는지 설명해주세요
- 배열 : 동일한 타입의 데이터를 저장하고 고정된 크기를 가지고 있다.
- 연결 리스트 : 동적으로 데이터를 추가/삭제 할 수 있고 각 데이터가 순서를 가지고 연결된 구조를 가지고 있다.
- 스택 : 순서가 보존되는 선형 데이터 구조. 후입선출 방식으로 데이터를 관리한다.
- 큐 : 가장 먼저 입력된 요소부터 처리하는 선입선출 방식으로 데이터를 관리한다.
- 해시 테이블 : 해시함수를 사용하여 변환한 값을 인덱스로 삼아 키와 데이터를 관리하는 자료구조이다. 데이터의 크기와 관계없이 삽입과 검색에 매우 효율적이다.
- 그래프 : 노드 사이에 방향이 있는 자료구조. 화살표가 없는 방향은 양방향을 뜻한다.
- 트리 : 그래프가 계층적 구조를 가진 형태이다. 최상위 노드를 가지고 있으며 상위 노드를 부모, 하위 노드를 자식으로 표현한다.
- 힙 : 이진트리 구조를 가진 자료구조. 부모의 키 값이 자식의 키 값보다 작거나 같으면 최소 힙, 크거나 같으면 최대 힙이다.

a. 위 자료구조는 무조건 좋은가요?
- 상황에 따라 다르지만 데이터가 많아지면 무조건 알고 있는 것이 중요하다고 생각합니다. 자료구조의 정의, 구현 방법, 사용처와 알고리즘 정도만 알고 있다면 괜찮다고 생각합니다. 

20. 객체지향이란 무엇인지 설명해주세요.
- 객체 지향 프로그래밍은 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.

(꼬리질문) 객체지향의 특징은 무엇이 있나요?
- 추상화 : 객체에서 공통된 속성과 행위를 찾아 추출해서 타입을 정의하는 과정. 불필요한 정보는 숨기고 필요한 정보만 노출시켜 프로그램을 간단하게 만드는 것.
- 캡슐화 : 변수와 함수를 결합 시켜 묶고 낮은 결합도를 유지할 수 있도록 설계하는 것.
- 상속 : 클래스의 속성과 행위를 하위 클래스에 물려주거나 하위 클래스가 상위 클래스의 속성과 행위를 물려받는 것. 재사용으로 인한 코드가 줄어든다.
- 다형성 : 하나의 변수명, 함수명이 상황에 따라 다른 의미로 해석 될 수 있는 것. 어떠한 요소에 여러 개념을 넣어 놓는 것. 오버로딩과 오버라이딩이 있다.
- 오버로딩 : 같은 이름의 메서드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것.
- 오버라이딩 : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용하는 것.

(꼬리질문) OOP란?
- Object-Oriented Programming 의 줄임말로 객체 지향 프로그래밍을 뜻합니다.

(꼬리질문) SOLID 원칙은 무엇인가요?
1. 단일 책임 원칙 (SRP, Single Responsibility Principle)
하나의 클래스는 단 하나의 책임만 가져야 한다. 단일 책임 원칙을 지키지 않을 경우 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.
2. 개방-폐쇄 원칙 (OCP, Open/Closed Principle)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.
3. 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)
프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)


21. 상속이란 무엇인지 프로젝트 내에 적용해 본 부분과 함께 예를 들어 설명해주세요.
- 상속은 부모 클래스인 기준 클래스로부터 새로운 파생(자식) 클래스를 만드는 것입니다. 상속을 사용하게 되면 기준(부모) 클래스의 private를 제외한 데이터 및 메서드들을 파생클래스에서 사용할 수 있게 됩니다. 파생(자식) 클래스는 기준(부모) 클래스로부터 물려 받는 멤버들 외에 자기 고유의 메서드와 데이터를 추가해서 사용할 수 있습니다.

22. 오버로딩과 오버라이딩의 차이점을 설명해주세요.
- 오버로딩은 같은 이름의 메서드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것이고, 오버라이딩은 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용하는 것을 말합니다.

23. 인터페이스와 추상클래스의 차이를 설명해주세요.
- 인터페이스는 생성자를 선언할 수 없지만 추상 클래스는 생성자를 선언할 수 있습니다. 또한 인터페이스는 클래스의 외부 능력을 정의하는 데 사용되며 추상 클래스는 클래스의 실제 ID를 정의하는 데 사용되고 객체 또는 동일한 클래스처럼 사용됩니다. 그리고 메소드의 서명만 공유하는 경우 인터페이스를 사용할 수 있지만 구현이 필요한 경우 추상 클래스가 사용됩니다.

24. 디자인 패턴(Singleton, Observer 등) 사용하는 이유는 무엇인가요?
- 디자인 패턴을 통해 프로그램 설계에 대한 추상화를 할 수 있고 프로그래머가 프로그램을 객체 관점보다 높은 레벨에서 생각할 수 있게 해줍니다. 그래서 프로그램의 구조 파악이 쉬워지고 재사용을 통한 개발 시간 단축 그리고 유지보수에 큰 장점을 가질 수 있습니다. 또한 프로그래머끼리 소통할 때에도 구조화된 패턴에 대한 사전 지식이 있다면 시간과 비용을 절약할 수 있습니다.

(꼬리질문) 프로젝트에 디자인패턴을 적용해 본 경험이 있나요? 왜 그 디자인패턴을 선택해서 구현하였나요?
- 게임에 하나만 존재해도 무방한 게임 매니저, 사운드 매니저 같은 객체를 싱글톤 패턴을 이용해 구현한 적이 있습니다.

(꼬리질문) Unity를 사용하면서 경험해볼 수 있는 대표적인 디자인패턴이 무엇인지 설명해주세요.
- 역시 게임을 만드는 엔진이다 보니 객체를 하나만 생성해서 사용하는 싱글톤 패턴이 가장 대표적이지 않을까 생각합니다.

25. MVC 모델이란 무엇인지 설명해주세요.
- MVC 는 Model, View, Controller의 약자 입니다. 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴입니다. 사용자가 Controller를 조작하면 Controller는 Model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 됩니다. Model은 애플리케이션의 정보, 데이터를 나타내고, View는 텍스트 입력, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타냅니다. 마지막으로 Controller는 사용자가 데이터를 클릭하고 수정하는 것에 대한 이벤트들을 처리하는 부분을 뜻합니다.

26. Unity 의 생명주기(Unity Life Cycle)에 대해서 설명해주세요.
- 유니티 스크립트의 대부분은 Monobehavior 클래스를 상속받습니다. 이 클래스를 상속받은 오브젝트는 씬에 있는 동안 엔진에서 일정한 흐름에 따라 자동으로 함수를 호출하는데 이 흐름을 생명 주기 라고 합니다. 자주 사용하는 함수들의 호출 순서는 Awake - OnEnable - Start - FixedUpdate - OnTrigger~~~ - OnCollision~~~ - Update - LastUpdate - OnApplicationQuit - OnDisable - OnDestroy 입니다.
![다운로드](https://github.com/dlghdwns97/Study/assets/73785455/c322a1c6-b699-43d3-8b5d-7c06f6109d4d)

27. MonoBehaviour 클래스의 주요 메서드와 그 기능에 대해 설명해주세요.
- MonoBehaviour 클래스에는 유니티에서 많이 사용하는 함수가 들어 있습니다. Awake, Start, Update, OnCollision~~~, OnTrigger~~~, GetComponent 등 게임 오브젝트와 관련된 생명 주기 함수들이 모두 들어 있습니다.
- Awake : 스크립트가 실행될 때 1번만 호출됩니다. 오브젝트의 초기화 또는 프리팹의 인스턴스화가 모두 진행된 직후에 호출됩니다.
- Start : 스크립트가 활성화될 때 1번만 호출됩니다.
- FixedUpdate : 고정된 프레임 주기로 호출됩니다.
- Update : 매 프레임마다 호출되는 함수로 디바이스 성능이나 최적화 상황에 따라 framerate가 변하므로 함수 호출 시간이 매번 달라집니다.
- OnTrigger~~~ : 두 오브젝트의 충돌 체크를 하는 함수. 콜라이더의 is Trigger 가 체크되어 있어야 함. 물리엔진 계산을 하지 않습니다.
- OnCollision~~~ : Rigidbody가 존재하는 오브젝트의 충돌 체크를 하는 함수. 물리엔진 계산을 해야하기 때문에 Rigidbody가 존재해야 합니다.
- OnEnable : 오브젝트가 활성화 될 때 호출됩니다. 이벤트 시작 함수로 사용합니다.
- OnDisable : 오브젝트가 비활성화 될 때 호출됩니다. 이벤트 종료 함수로 사용합니다.
- OnDestory : 오브젝트 생존 기간의 마지막 프레임이 업데이트된 후 실행됩니다.

28. Unity 오브젝트가 다양하게 씬에 올라와 있다면 동시에 시작되고 무엇이 먼저 초기화 되는지 알 수 없을 수 있는데, 프로젝트에서 코드를 만들 때 이에 대해 고민하고 해결해본 경험이 있다면 설명해주세요.
-

29. Update의 종류와 각각 어떤 특징을 가지고 있는지 설명해주세요.
-

30. 서로 다른 성능을 가진 기기에서 Update 사용 시 주의할 점에 대해 설명해주세요.
-
