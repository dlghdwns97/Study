1. float와 int의 표현 가능한 수의 범위가 다른 이유는 무엇인가요?
- 둘 다 같은 4바이트 자료형이지만 int형은 있는 그대로의 비트를 보여주고 float형은 부호를 표현하는 비트, 자릿수를 표현하는 비트, 값을 표현하는 비트 3부분으로 나뉘어서 그렇습니다.

2. ref와 out 사용 시 차이는 무엇인가요?
- ref를 사용하면 함수 바깥에 있는 인자를 함수로 넘겨주는 형태로, out을 사용하면 함수 내에서 정의한 값을 바깥으로 넘겨주는 형태로 작동합니다. 그래서 out을 이용한 함수는 함수 바깥에 있는 변수에 값을 할당 할 필요가 없지만 ref를 이용한 함수는 바깥에 있는 변수에 값을 할당해주지 않으면 에러가 발생합니다.

3. 접근제한자란 무엇이며, 각각 어떤 차이가 있는지 비교해서 설명해주세요.
- 접근제한자는 외부로부터 타입 또는 그 멤버들로의 접근을 제한할 때 사용하는 것으로 4종류가 있습니다. public은 모든 외부에서 이 타입에 접근할 수 있습니다. private는 동일 클래스나 구조체 내의 멤버만 접근 가능합니다. protected는 상속 클래스와 선언 클래스에서만 접근 가능합니다. internal은 동일한 같은 프로젝트 같이 어셈블리 내에 있는 다른 타입들만 접근할 수 있습니다. 접근제한자를 사용하지 않으면 기본적으로 internal 이 붙습니다.

- ![img](https://github.com/dlghdwns97/Study/assets/73785455/9898f6f7-3b95-42ae-aa98-75506ab5d854)

4. struct와 class를 비교해서 설명해주세요.
- 구조체는 상속이 불가능하고 값 타입이지만 클래스는 상속이 가능한 참조 타입입니다. 구조체는 스택이라는 메모리 영역에 할당되고 클래스는 힙에 할당하는 값의 주소를 가지고 있습니다. 그래서 사용을 할 때 구조체의 변수는 이미 스택에 할당되어 있어서 바로 불러와 사용이 가능하지만 클래스는 new 키워드를 통해 힙 영역에 할당한 뒤 그 주소값을 참조해야 합니다. C# 의 경우 가비지 컬렉터가 힙에 할당된 메모리 중 사용하지 않는 부분을 정리해주는데 이때 처리해야할 양이 많다면 프로그램이 느려지게 됩니다. 그래서 굳이 힙에 할당하지 않아도 되는 정보의 경우 스택 메모리에서 사용하면 사용 후 바로 종료가 되기 때문에 프로그램 속도 향상에 도움이 될 수 있습니다.

5. 가비지 컬렉터에 대해 설명해주세요.
- 가비지 컬렉터는 필요없는 동적 메모리를 해제하는 C#의 자동 메모리 관리 기능입니다. 가비지 컬렉터는 프로그램을 실행하다가 특정한 타이밍에 현재 할당된 메모리를 조사해서 그것이 현재 접근 가능한 상태인지 불가능한 상태인지 분류한 뒤 접근이 불가능한 메모리를 쓰레기로 간주하여 해제시킵니다. 하지만 모든 메모리를 조사하는건 실시간으로 동작하는 프로그램에서 끊기는 현상을 유발할 수 있기 때문에 요즘은 점진적으로 여러번에 걸쳐서 수행하는 방식을 사용하는 것으로 알고 있습니다.

6. 가비지 컬렉터를 회피하기 위한 전략은 무엇이 있나요?
- 우선 첫번째로 메모리 할당을 최소화시키면 됩니다. 변수를 재사용한다던가 하는 방법으로 할당을 최소화하면 가비지컬렉터의 동작빈도를 줄일 수 있습니다. 두번째로는 가비지컬렉션 메소드를 직접 호출하는 빈도를 줄이고 정말 필요한 경우에만 직접 호출하는 방법이 있습니다. 세번째로는 굳이 참조 타입이 필요하지 않다면 값 타입을 사용하는 방법이 있습니다. 하지만 이 경우에는 코드의 유지보수성이나 최적화에 문제가 될 수 있으므로 실제로 가비지컬렉터가 성능저하를 일으킬 때가 아니면 남발하지 않는 것이 좋다고 생각합니다.

추가 )
IDisposable 인터페이스 사용
IDisposable 인터페이스를 구현한 클래스는 Dispose()메서드를 호출함으로써 자체적으로 리소스를 해제할 수 있다.
이 방법을 통해 가비지 컬렉터가 처리해야 할 작업을 줄일 수 있다.

using (var resource = new DisposableResource()) // IDisposable 인터페이스를 구현한 클래스
{
	resource.Use();
} // using 블록이 끝나면 Dispose() 메서드가 자동으로 호출됨
https://learn.microsoft.com/ko-kr/dotnet/api/system.idisposable?view=net-7.0

Finalizer 사용 최소화
FInalizer는 객체가 가비지 컬렉션에 의해 수거되기 전 호출되는 특수 메서드이다.
Finalizer를 사용하면 가비지 컬렉션의 프로세스가 느려질 수 있으므로, 꼭 필요한 경우에만 사용하는 것이 좋다.

public class ClassWithoutFinalizer
{
	// Finalizer 없음.
}
https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/classes-and-structs/finalizers

7. 가비지 컬렉션이란 무엇인지 설명해주세요.
- 메모리 관리 방법중 하나로 프로그래머가 동적으로 할당한 메모리 영역 중 더 이상 쓰이지 않는 영역을 자동으로 찾아 해제하는 기능입니다. 가비지 컬렉터라는 소프트웨어가 이 기능을 담당하고 있습니다.

8. 박싱과 언박싱에 대하여 설명해주세요.
- 박싱은 값 타입의 개체를 참조 타입으로 변환하는 작업을 말합니다. 언박싱은 반대로 참조 타입으로 있는 개체를 값 타입으로 변환하는 작업을 말합니다.
```csharp
int a = 10;
object b = a; // 박싱
int c = (int)b; // 언박싱
```
(꼬리질문) 박싱, 언박싱을 사용할 때 주의해야 할 점이 있다면 무엇이 있나요?
- 일단 두 작업 모두 스택에서 힙으로 복사, 힙에서 스택으로 복사하는 과정이 추가되기 때문에 리소스를 더 사용하게 됩니다. 그래서 정말 필요한 경우가 아니면 사용하지 않는 것이 좋고 특히 언박싱은 기존과 다른 타입으로 언박싱 하거나 해당 타입보다 작은 범위로 변환을 하면 에러가 호출되기 때문에 is 연산자를 사용해서 미리 같은 타입인지 캐스팅 해보는 작업이 필요합니다.

9. 배열과 List, ArrayList, Dictionary 의 차이점을 설명해주세요.
- 배열은 크기가 고정되어 있는 동일한 타입의 원소 집합입니다. 고정된 크기를 가지고 있어 메모리 효율이 좋고 배열을 구성하는 원소에게 접근이 용이하지만 크기 변경이 불가능하고 데이터를 자주 바꿔야하는 경우엔 알맞지 않습니다. 리스트는 크기가 동적인 동일한 타입의 원소 집합입니다. 원소를 추가하거나 제거하는 경우가 잦다면 배열보다는 리스트를 사용하는 것이 좋습니다. ArrayList는 크기가 동적인 모든 타입의 원소 집합입니다. 리스트와 마찬가지로 원소를 추가하거나 제거하는 경우가 잦을 때 사용하며 모든 타입의 원소를 저장할 수 있습니다. 하지만 제네릭이 없어 타입 안정성은 떨어집니다.(잘못된 데이터를 추가할 수 있음) 딕셔너리는 키와 값의 쌍으로 이루어진 집합입니다. 키를 통해 값을 찾거나 데이터 간의 연관성을 직관적으로 보여줘야 할 때 사용합니다. 키 값은 중복값을 가질 수 없습니다.

(꼬리질문) Dictionary는 어떻게 구현해야 하나요?
- 딕셔너리는 해쉬 테이블 기반으로 구현되어 있습니다. 해쉬는 특정 키를 해쉬 함수를 통해 해쉬 테이블의 주소값으로 변경합니다. 그리고 그 해쉬 함수가 값이 저장될 위치를 가리키고 해당 위치에 값이 저장됩니다.

(꼬리질문) Dictionary 검색이 빠른 이유는 무엇인가요?
- 저장할 때 key 값에 해쉬 함수를 적용해 고유한 index 를 만들어 저장하기 때문입니다. key 를 알면 해쉬 함수를 통해 바로 index 를 알 수 있으므로 데이터를 찾을 때 O(1) 의 평균 시간복잡도로 조회, 삭제가 가능합니다.

10. 제네릭이란 무엇인가요?
- 제네릭은 데이터 형식을 지정하지 않고 형식 매개변수로 전달해서 클래스를 정의하는 것을 말합니다. 제네릭을 사용할 경우 데이터 형식별로 클래스를 생성하지 않아 재사용성, 안전성 등을 최대화 할 수 있습니다.
```csharp
using System;

namespace Project
{
    class Program
    {
        static void Main(string[] args)
        {
            GenericQueue<int> intData = new GenericQueue<int>(100);

            intData.Enqueue(100);
            intData.Enqueue(200);
            intData.Enqueue(300);

            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());

            intData.Enqueue(400);
            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());
        }   
    }

    class GenericQueue<T>
    {
        public T[] array;
        private int count = 0;

        public GenericQueue(int length)
        {
            array = new T[length];
        }

        public void Enqueue(T value)
        {
            array[++count] = value;
        } 

        public T Dequeue()
        {
            return count == 0 ? default(T) : array[count--];
        }
    }
}
```
