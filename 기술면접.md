1. float와 int의 표현 가능한 수의 범위가 다른 이유는 무엇인가요?
- 둘 다 같은 4바이트 자료형이지만 int형은 있는 그대로의 비트를 보여주고 float형은 부호를 표현하는 비트, 자릿수를 표현하는 비트, 값을 표현하는 비트 3부분으로 나뉘어서 그렇습니다.

2. ref와 out 사용 시 차이는 무엇인가요?
- ref를 사용하면 함수 바깥에 있는 인자를 함수로 넘겨주는 형태로, out을 사용하면 함수 내에서 정의한 값을 바깥으로 넘겨주는 형태로 작동합니다. 그래서 out을 이용한 함수는 함수 바깥에 있는 변수에 값을 할당 할 필요가 없지만 ref를 이용한 함수는 바깥에 있는 변수에 값을 할당해주지 않으면 에러가 발생합니다.

3. 접근제한자란 무엇이며, 각각 어떤 차이가 있는지 비교해서 설명해주세요.
- 접근제한자는 외부로부터 타입 또는 그 멤버들로의 접근을 제한할 때 사용하는 것으로 4종류가 있습니다. public은 모든 외부에서 이 타입에 접근할 수 있습니다. private는 동일 클래스나 구조체 내의 멤버만 접근 가능합니다. protected는 상속 클래스와 선언 클래스에서만 접근 가능합니다. internal은 동일한 같은 프로젝트 같이 어셈블리 내에 있는 다른 타입들만 접근할 수 있습니다. 접근제한자를 사용하지 않으면 기본적으로 internal 이 붙습니다.

- ![img](https://github.com/dlghdwns97/Study/assets/73785455/9898f6f7-3b95-42ae-aa98-75506ab5d854)

4. struct와 class를 비교해서 설명해주세요.
- 구조체는 상속이 불가능하고 값 타입이지만 클래스는 상속이 가능한 참조 타입입니다. 구조체는 스택이라는 메모리 영역에 할당되고 클래스는 힙에 할당하는 값의 주소를 가지고 있습니다. 그래서 사용을 할 때 구조체의 변수는 이미 스택에 할당되어 있어서 바로 불러와 사용이 가능하지만 클래스는 new 키워드를 통해 힙 영역에 할당한 뒤 그 주소값을 참조해야 합니다. C# 의 경우 가비지 컬렉터가 힙에 할당된 메모리 중 사용하지 않는 부분을 정리해주는데 이때 처리해야할 양이 많다면 프로그램이 느려지게 됩니다. 그래서 굳이 힙에 할당하지 않아도 되는 정보의 경우 스택 메모리에서 사용하면 사용 후 바로 종료가 되기 때문에 프로그램 속도 향상에 도움이 될 수 있습니다.

5. 가비지 컬렉터에 대해 설명해주세요.
- 가비지 컬렉터는 필요없는 동적 메모리를 해제하는 C#의 자동 메모리 관리 기능입니다. 가비지 컬렉터는 프로그램을 실행하다가 특정한 타이밍에 현재 할당된 메모리를 조사해서 그것이 현재 접근 가능한 상태인지 불가능한 상태인지 분류한 뒤 접근이 불가능한 메모리를 쓰레기로 간주하여 해제시킵니다. 하지만 모든 메모리를 조사하는건 실시간으로 동작하는 프로그램에서 끊기는 현상을 유발할 수 있기 때문에 요즘은 점진적으로 여러번에 걸쳐서 수행하는 방식을 사용하는 것으로 알고 있습니다.

6. 가비지 컬렉터를 회피하기 위한 전략은 무엇이 있나요?
- 우선 첫번째로 메모리 할당을 최소화시키면 됩니다. 변수를 재사용한다던가 하는 방법으로 할당을 최소화하면 가비지컬렉터의 동작빈도를 줄일 수 있습니다. 두번째로는 가비지컬렉션 메소드를 직접 호출하는 빈도를 줄이고 정말 필요한 경우에만 직접 호출하는 방법이 있습니다. 세번째로는 굳이 참조 타입이 필요하지 않다면 값 타입을 사용하는 방법이 있습니다. 하지만 이 경우에는 코드의 유지보수성이나 최적화에 문제가 될 수 있으므로 실제로 가비지컬렉터가 성능저하를 일으킬 때가 아니면 남발하지 않는 것이 좋다고 생각합니다.

추가 )
IDisposable 인터페이스 사용
IDisposable 인터페이스를 구현한 클래스는 Dispose()메서드를 호출함으로써 자체적으로 리소스를 해제할 수 있다.
이 방법을 통해 가비지 컬렉터가 처리해야 할 작업을 줄일 수 있다.

using (var resource = new DisposableResource()) // IDisposable 인터페이스를 구현한 클래스
{
	resource.Use();
} // using 블록이 끝나면 Dispose() 메서드가 자동으로 호출됨
https://learn.microsoft.com/ko-kr/dotnet/api/system.idisposable?view=net-7.0

Finalizer 사용 최소화
FInalizer는 객체가 가비지 컬렉션에 의해 수거되기 전 호출되는 특수 메서드이다.
Finalizer를 사용하면 가비지 컬렉션의 프로세스가 느려질 수 있으므로, 꼭 필요한 경우에만 사용하는 것이 좋다.

public class ClassWithoutFinalizer
{
	// Finalizer 없음.
}
https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/classes-and-structs/finalizers

7. 가비지 컬렉션이란 무엇인지 설명해주세요.
- 메모리 관리 방법중 하나로 프로그래머가 동적으로 할당한 메모리 영역 중 더 이상 쓰이지 않는 영역을 자동으로 찾아 해제하는 기능입니다. 가비지 컬렉터라는 소프트웨어가 이 기능을 담당하고 있습니다.

8. 박싱과 언박싱에 대하여 설명해주세요.
- 박싱은 값 타입의 개체를 참조 타입으로 변환하는 작업을 말합니다. 언박싱은 반대로 참조 타입으로 있는 개체를 값 타입으로 변환하는 작업을 말합니다.
```csharp
int a = 10;
object b = a; // 박싱
int c = (int)b; // 언박싱
```
(꼬리질문) 박싱, 언박싱을 사용할 때 주의해야 할 점이 있다면 무엇이 있나요?
- 일단 두 작업 모두 스택에서 힙으로 복사, 힙에서 스택으로 복사하는 과정이 추가되기 때문에 리소스를 더 사용하게 됩니다. 그래서 정말 필요한 경우가 아니면 사용하지 않는 것이 좋고 특히 언박싱은 기존과 다른 타입으로 언박싱 하거나 해당 타입보다 작은 범위로 변환을 하면 에러가 호출되기 때문에 is 연산자를 사용해서 미리 같은 타입인지 캐스팅 해보는 작업이 필요합니다.

9. 배열과 List, ArrayList, Dictionary 의 차이점을 설명해주세요.
- 배열은 크기가 고정되어 있는 동일한 타입의 원소 집합입니다. 고정된 크기를 가지고 있어 메모리 효율이 좋고 배열을 구성하는 원소에게 접근이 용이하지만 크기 변경이 불가능하고 데이터를 자주 바꿔야하는 경우엔 알맞지 않습니다. 리스트는 크기가 동적인 동일한 타입의 원소 집합입니다. 원소를 추가하거나 제거하는 경우가 잦다면 배열보다는 리스트를 사용하는 것이 좋습니다. ArrayList는 크기가 동적인 모든 타입의 원소 집합입니다. 리스트와 마찬가지로 원소를 추가하거나 제거하는 경우가 잦을 때 사용하며 모든 타입의 원소를 저장할 수 있습니다. 하지만 제네릭이 없어 타입 안정성은 떨어집니다.(잘못된 데이터를 추가할 수 있음) 딕셔너리는 키와 값의 쌍으로 이루어진 집합입니다. 키를 통해 값을 찾거나 데이터 간의 연관성을 직관적으로 보여줘야 할 때 사용합니다. 키 값은 중복값을 가질 수 없습니다.

(꼬리질문) Dictionary는 어떻게 구현해야 하나요?
- 딕셔너리는 해쉬 테이블 기반으로 구현되어 있습니다. 해쉬는 특정 키를 해쉬 함수를 통해 해쉬 테이블의 주소값으로 변경합니다. 그리고 그 해쉬 함수가 값이 저장될 위치를 가리키고 해당 위치에 값이 저장됩니다.

(꼬리질문) Dictionary 검색이 빠른 이유는 무엇인가요?
- 저장할 때 key 값에 해쉬 함수를 적용해 고유한 index 를 만들어 저장하기 때문입니다. key 를 알면 해쉬 함수를 통해 바로 index 를 알 수 있으므로 데이터를 찾을 때 O(1) 의 평균 시간복잡도로 조회, 삭제가 가능합니다.

### List
C#에서 List가 동적으로 크기를 정할수 있기 때문에 노드 방식으로 생각하고 계신 분들이 계신데 내부적으로는 배열로 구현되어 있습니다.
List<int> myList = new List<int>();
리스트를 만들면 내부적으로는 배열을 미리 생성을 해둡니다.
이때 만들어지는 기본 배열의 0개 짜리입니다.
내부 배열 - [   ]
myList.Add(10);
이후 데이터를 추가하게 되면 배열이 비어있는지 아닌지 체크를 합니다.
비어다면 기본 용량만큼 배열을 새로 만들어줍니다.
(TMI - 기본 용량는 구현체 마다 다르지만 C# 에서는 기본적으로 4개짜리 배열을 생성하게 됩니다.)
내부 배열 - [10][   ][   ][   ]
myList.Add(20);
myList.Add(30);
myList.Add(40);
데이터를 추가하면 배열이 남아 있으면 계속 해서 채워 나갑니다.
내부 배열 - [10][20][30][40]
myList.Add(50);
배열이 꽉찬 상태에서 데이터를 추가하면 배열 사이즈의 2배만큼 새로운 배열을 만듭니다.
이때 기존 배열과 완전히 다른 새로운 배열을 만들어서 데이터를 옮기게 됩니다.
이말은 기존 배열은 아직 유지되어 있는 상태이고 이후 CG의 대상이 됩니다.
내부 배열 - [10][20][30][40][50][   ][   ][   ]       <- 새로 생긴거
기존 배열 - [10][20][30][40]                              <- 이전에 쓰던거 (GC 의 대상)
이렇게 사용해다가면 데이터를 계속 추가를 할때마다 새로운 배열을 만들게 됩니다.
숫자가 가늠이 된다면 List 를 사용하실때도 대략적인 사이즈를 지정해 주신다면 처음 배열을 만들때 내부 배열의 사이즈를 조정할 수 있습니다.
이렇게 된다면 배열을 옮김으로서 생기는 부하를 방지할 수 있습니다.
List<int> myList = new List<int>(10);
내부 배열 - [   ][   ][   ][   ][   ][   ][   ][   ][   ][   ]
결론
리스트는 내부적으로 배열이다.
리스트도 가능하면 배열 크기를 먼저 정해주면 부하를 줄일 수 있다.
리스트의 삽입/삭제시 내부적으로 배열 중간의 데이터를 추가/지우고 다른 데이터를 옮겨야 하기 때문에 성능은 O(n) 이 됩니다. (주의 - 사용이 한번에 된다고 O(1) 이 아닙니다)
리스트 내부 데이터는 메모리에 연속적으로 할당됩니다.(배열이기 때문에)
List 와 Linked List 는 다릅니다.
간략하게 텍스트로 공유드리니 해당 내용 한번 학습해보시면 좋을것같습니다.
아마 List 와 Linked List 의 내용을 혼동하셔서 잘못 작성하신 분들이 계시는것같습니다.
구조를 완벽히 알 필요는 없지만 대략적인 동작원리는 파악하시면 도움이 됩니다.

10. 제네릭이란 무엇인가요?
- 제네릭은 데이터 형식을 지정하지 않고 형식 매개변수로 전달해서 클래스를 정의하는 것을 말합니다. 제네릭을 사용할 경우 데이터 형식별로 클래스를 생성하지 않아 재사용성, 안전성 등을 최대화 할 수 있습니다.
```csharp
using System;

namespace Project
{
    class Program
    {
        static void Main(string[] args)
        {
            GenericQueue<int> intData = new GenericQueue<int>(100);

            intData.Enqueue(100);
            intData.Enqueue(200);
            intData.Enqueue(300);

            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());

            intData.Enqueue(400);
            Console.WriteLine(intData.Dequeue());
            Console.WriteLine(intData.Dequeue());
        }   
    }

    class GenericQueue<T>
    {
        public T[] array;
        private int count = 0;

        public GenericQueue(int length)
        {
            array = new T[length];
        }

        public void Enqueue(T value)
        {
            array[++count] = value;
        } 

        public T Dequeue()
        {
            return count == 0 ? default(T) : array[count--];
        }
    }
}
```

11. 델리게이트(Delegate)의 개념에 대해 설명해주세요.
- 델리게이트는 메서드에 대한 참조를 갖는 형식입니다. 여러 메서드를 등록해 한번의 호출로 등록된 모든 메서드를 호출할 수 있습니다.

12. 'delegate', 'event', 'action', 'func' 간의 차이를 설명해주세요.
- 델리게이트, 액션, func는 일단 모두 델리게이트와 같은 대리자 형태를 가지고 있습니다. 가장 기본적인 형태가 델리게이트이고 action과 func는 C# 내부적으로 정의하고 있는 대리자 입니다. action은 인자만 존재하는 대리자, func은 인자와 결과 값이 모두 존재하는 대리자입니다. 이벤트는 대리자를 오직 변수를 선언한 클래스 내부에서만 쓸 수 있게해주는 키워드 입니다. 이벤트는 클래스 내부에서만 실행할 대리자니 다른 곳에서 사용하지 못하게 하라고 컴파일러에 명시적으로 알려주는 기능을 합니다.

(꼬리질문) 프로젝트에 적용해 본 경험이 있다면 설명해주세요.
- 아직 없..네

13. 람다식(Lambda Expression)이 무엇인지 설명해주세요.
- 람다식은 무명 함수를 표현하는데 사용됩니다. 연산자로는 => 를 사용하며 연산자 왼쪽에 입력 파라미터를, 연산자 오른쪽에 실행할 문장 블럭을 입력합니다. 람다식을 이용하면 델리게이트를 더 간편하게 표현할 수 있습니다.

14. 콜백이란 무엇인가요? 사용해봤는지?
- 콜백은 피호출자가 호출자를 다시 호출하는 것으로 비동기 처리가 많을 때 유용하게 사용됩니다. 콜백에는 객체를 전달하지 않고 메서드를 담아 전달해 사용할 수 있는 델리게이트가 많이 사용됩니다.

15. 정렬 알고리즘이란 무엇이며, 사용 이유에 대해 설명해주세요.
- 어떤 데이터 집합을 정해진 순서대로 나열하는 것을 말합니다. 데이터를 정렬하는 이유는 탐색을 위해서이고 그중에서도 이진 탐색이라는 아주 강력한 알고리즘을 사용하기 위해서 정렬을 사용합니다.
